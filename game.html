<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>Synthwave Shooter: Neon Crisis DX</title>
    <style>
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden;
        }
        body {
            background-color: #050505;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 80px rgba(255, 0, 255, 0.4), 0 0 20px rgba(0, 255, 255, 0.4);
            border: 4px solid #333;
            border-image: linear-gradient(to right, #00ffff, #ff00ff) 1;
        }

        canvas { display: block; background-color: #000000; }

        /* UI Elements */
        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            background: rgba(0, 0, 0, 0.85); z-index: 20;
            text-align: center; text-shadow: 0 0 10px #ff00ff;
        }
        .hidden { display: none !important; }

        h1 { font-size: 60px; margin-bottom: 20px; color: #00ffff; text-shadow: 4px 4px 0px #ff00ff; }
        p { font-size: 20px; color: #ddd; margin-bottom: 40px; }
        
        button {
            background: transparent; color: #00ffff; border: 2px solid #00ffff;
            padding: 15px 40px; font-size: 24px; font-family: inherit; cursor: pointer;
            box-shadow: 0 0 15px #00ffff; transition: all 0.2s; text-transform: uppercase;
        }
        button:hover { background: #00ffff; color: #000; box-shadow: 0 0 30px #00ffff; }

        .scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%);
            background-size: 100% 4px; pointer-events: none; z-index: 10;
        }
        
        .noise {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 11; opacity: 0.05;
            background-image: url('data:image/svg+xml;utf8,%3Csvg viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg"%3E%3Cfilter id="noiseFilter"%3E%3CfeTurbulence type="fractalNoise" baseFrequency="0.65" numOctaves="3" stitchTiles="stitch"/%3E%3C/filter%3E%3Crect width="100%25" height="100%25" filter="url(%23noiseFilter)"/%3E%3C/svg%3E');
        }

        #hud {
            position: absolute; top: 10px; left: 10px; z-index: 15; pointer-events: none;
            text-shadow: 0 0 5px #00ffff; font-weight: bold; font-size: 20px;
            display: flex; gap: 20px;
        }
        #levelDisplay {
            position: absolute; top: 10px; right: 20px; z-index: 15;
            font-size: 24px; color: #ff00ff; text-shadow: 0 0 10px #ff00ff; font-weight: bold;
        }
        #comboDisplay {
            position: absolute; top: 50px; left: 10px; z-index: 15;
            font-size: 18px; color: #ffff00; text-shadow: 0 0 10px #ffff00;
            opacity: 0; transition: opacity 0.2s;
        }
    </style>
</head>
<body>

<div id="gameContainer">
    <canvas id="gameCanvas" width="800" height="600" tabindex="0"></canvas>
    <div class="scanlines"></div>
    <div class="noise"></div>
    
    <div id="hud">
        <span>SCORE: <span id="scoreVal">0</span></span>
        <span>HIGH: <span id="highScoreVal">0</span></span>
    </div>
    <div id="comboDisplay">COMBO x<span id="comboVal">0</span></div>
    <div id="levelDisplay">LEVEL 1</div>

    <!-- Start Screen -->
    <div id="startScreen" class="overlay">
        <h1>NEON CRISIS DX</h1>
        <p>ARROWS to Move | SPACE to Shoot/Start</p>
        <button onclick="startGame()">INSERT COIN</button>
    </div>

    <div id="gameOverScreen" class="overlay hidden">
        <h1 style="color: #ff0055; text-shadow: 4px 4px 0px #ffffff;">GAME OVER</h1>
        <p>FINAL SCORE: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">TRY AGAIN</button>
    </div>
</div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const GAME_WIDTH = 800;
    const GAME_HEIGHT = 600;

    // --- Audio System ---
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    
    function initAudio() {
        if (!audioCtx) audioCtx = new AudioContext();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    const sfx = {
        playTone: (type, freqStart, freqEnd, duration, vol=0.1) => {
            try {
                if (!audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.type = type;
                osc.frequency.setValueAtTime(freqStart, audioCtx.currentTime);
                if (freqEnd) osc.frequency.exponentialRampToValueAtTime(freqEnd, audioCtx.currentTime + duration);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch (e) { console.error("Audio error", e); }
        },
        laser: () => sfx.playTone('sawtooth', 800, 100, 0.2, 0.05),
        explosion: () => sfx.playTone('square', 100, 10, 0.4, 0.1),
        hit: () => sfx.playTone('triangle', 300, 100, 0.1, 0.05),
        powerup: () => {
            if (!audioCtx) return;
            // Arpeggio sound
            [440, 554, 659].forEach((f, i) => {
                setTimeout(() => sfx.playTone('sine', f, null, 0.1, 0.05), i * 50);
            });
        },
        bossCharge: () => sfx.playTone('sawtooth', 100, 600, 1.0, 0.05),
        bossLaser: () => sfx.playTone('square', 800, 200, 0.5, 0.15)
    };

    // Background Music logic
    let bgmAudio = new Audio('good.mp3');
    bgmAudio.loop = true;
    bgmAudio.volume = 0.4;

    function startBGM() {
        if (bgmAudio) {
            bgmAudio.currentTime = 0;
            const playPromise = bgmAudio.play();
            if (playPromise !== undefined) {
                playPromise.catch(error => {
                    console.warn("BGM Auto-play blocked or file missing. Interacting might fix this.", error);
                });
            }
        }
    }
    
    function stopBGM() {
        if (bgmAudio) {
            bgmAudio.pause();
            bgmAudio.currentTime = 0;
        }
    }

    // --- Game Config & State ---
    const COLORS = {
        bg: '#000000', grid: '#00FFFF', player: '#FF00FF', laser: '#00FFFF',
        enemy: '#FF0000', enemyTank: '#FF4500', boss: '#FFFFFF',
        missile: '#FFaa00', powerup: '#00FF00', shield: '#00ccff'
    };

    let gameState = 'START';
    let level = 1;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('synthShooterHighScore')) || 0;
    let scrollSpeed = 3;
    let scrollOffset = 0;
    
    // Juice Vars
    let shakeIntensity = 0;
    let combo = 0;
    let comboTimer = 0;
    let glitchTimer = 0;

    const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false };

    // Entities
    let lasers = [];
    let enemies = [];
    let enemyMissiles = [];
    let groundMissiles = [];
    let particles = [];
    let powerups = [];
    let boss = null;
    let stars = []; // Parallax stars

    // --- Classes ---

    class Player {
        constructor() {
            this.x = 100; this.y = 300;
            this.width = 40; this.height = 30;
            this.speed = 6;
            this.hp = 1;
            this.hasShield = false;
            this.powerUpType = 'NORMAL'; // NORMAL, TRIPLE, RAPID
            this.powerUpTimer = 0;
            this.trail = []; // Stores previous positions
            this.invulnerable = 0;
            this.fireTimer = 10;
            this.fireInterval = 10;
        }

        draw() {
            ctx.save();
            // Trail Effect
            this.trail.forEach((pos, index) => {
                ctx.globalAlpha = 0.1 + (index / 10) * 0.3;
                ctx.fillStyle = this.hasShield ? COLORS.shield : COLORS.player;
                ctx.beginPath();
                ctx.moveTo(pos.x + 20, pos.y);
                ctx.lineTo(pos.x - 20, pos.y - 15);
                ctx.lineTo(pos.x - 20, pos.y + 15);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            if (this.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0) {
                // Blink when hit/shield broken
            } else {
                ctx.translate(this.x, this.y);
                ctx.shadowBlur = 20;
                ctx.shadowColor = this.hasShield ? COLORS.shield : COLORS.player;
                ctx.fillStyle = this.hasShield ? '#AAFFFF' : COLORS.player;
                
                // Ship
                ctx.beginPath();
                ctx.moveTo(20, 0); ctx.lineTo(-20, -15); ctx.lineTo(-15, 0); ctx.lineTo(-20, 15);
                ctx.closePath();
                ctx.fill();

                // Shield Aura
                if (this.hasShield) {
                    ctx.strokeStyle = COLORS.shield;
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.arc(0,0, 30, 0, Math.PI*2); ctx.stroke();
                }

                // Engine
                ctx.beginPath();
                ctx.moveTo(-18, -8);
                ctx.lineTo(-18 - (Math.random() * 20 + 10), 0);
                ctx.lineTo(-18, 8);
                ctx.fillStyle = '#00FFFF'; ctx.shadowColor = '#00FFFF'; ctx.fill();
            }
            ctx.restore();
        }

        update() {
            // Trail recording
            this.trail.push({x: this.x, y: this.y});
            if (this.trail.length > 5) this.trail.shift();

            // Movement
            let currentSpeed = this.speed;
            if (this.powerUpType === 'RAPID') currentSpeed += 2;

            if (keys.ArrowUp && this.y > 30) this.y -= currentSpeed;
            if (keys.ArrowDown && this.y < GAME_HEIGHT - 30) this.y += currentSpeed;
            if (keys.ArrowLeft && this.x > 30) this.x -= currentSpeed;
            if (keys.ArrowRight && this.x < GAME_WIDTH - 30) this.x += currentSpeed;

            // Powerup expiration
            if (this.powerUpType !== 'NORMAL') {
                this.powerUpTimer--;
                if (this.powerUpTimer <= 0) this.powerUpType = 'NORMAL';
            }
            if (this.invulnerable > 0) this.invulnerable--;

            // Auto-fire
            if (keys.Space) {
                this.fireTimer++;
                if (this.fireTimer >= this.fireInterval) {
                    this.fire();
                    this.fireTimer = 0;
                }
            } else {
                this.fireTimer = this.fireInterval;
            }
        }

        fire() {
            if (this.powerUpType === 'TRIPLE') {
                lasers.push(new Laser(this.x + 20, this.y, 0));
                lasers.push(new Laser(this.x + 20, this.y, -0.2)); // Angled Up
                lasers.push(new Laser(this.x + 20, this.y, 0.2));  // Angled Down
            } else {
                lasers.push(new Laser(this.x + 20, this.y, 0));
            }
            sfx.laser();
        }

        hit() {
            if (this.invulnerable > 0) return false;
            if (this.hasShield) {
                this.hasShield = false;
                this.invulnerable = 60; // 1 sec invulnerability
                sfx.playTone('sine', 500, 100, 0.3); // Shield break sound
                addShake(10);
                return false; // Not dead
            }
            return true; // Dead
        }
    }

    class Laser {
        constructor(x, y, vy) {
            this.x = x; this.y = y; this.vx = 15; this.vy = vy * 15;
            this.width = 40; this.height = 6;
            if (player.powerUpType === 'RAPID') this.vx = 25;
            this.markedForDeletion = false;
        }
        update() { 
            this.x += this.vx; this.y += this.vy;
            if (this.x > GAME_WIDTH) this.markedForDeletion = true; 
        }
        draw() {
            ctx.save();
            ctx.shadowBlur = 10; ctx.shadowColor = COLORS.laser; ctx.fillStyle = COLORS.laser;
            ctx.translate(this.x, this.y);
            ctx.rotate(Math.atan2(this.vy, this.vx));
            ctx.fillRect(0, -3, this.width, this.height);
            ctx.restore();
        }
    }

    class Enemy {
        constructor(type = 'NORMAL') {
            this.type = type;
            this.radius = 20;
            this.x = GAME_WIDTH + 50;
            this.y = Math.random() * (GAME_HEIGHT - 150) + 50;
            this.markedForDeletion = false;
            this.hitFlash = 0;
            
            // Stats based on type
            if (type === 'TANK') {
                this.hp = 3;
                this.speed = 1.5;
                this.color = COLORS.enemyTank;
                this.radius = 30;
                this.fireInterval = 150;
            } else if (type === 'KAMIKAZE') {
                this.hp = 1;
                this.speed = 5;
                this.color = '#ff9900';
                this.fireInterval = 9999; // Doesn't shoot, just rams
            } else {
                this.hp = 1;
                this.speed = Math.random() * 2 + 2 + (level * 0.5);
                this.color = COLORS.enemy;
                this.fireInterval = Math.random() * 100 + 100;
            }
            this.fireTimer = Math.random() * this.fireInterval;
        }
        
        update() {
            this.x -= this.speed;
            
            if (this.type === 'KAMIKAZE') {
                // Track player Y slowly
                if (this.y < player.y) this.y += 1.5;
                else this.y -= 1.5;
            }

            // Shooting
            this.fireTimer++;
            if (this.fireTimer > this.fireInterval) {
                if (this.type === 'TANK') {
                    // Big shot
                    enemyMissiles.push(new EnemyMissile(this.x, this.y, -5, 0, 10));
                } else if (this.type === 'NORMAL') {
                    enemyMissiles.push(new EnemyMissile(this.x, this.y, -7, 0, 6));
                }
                this.fireTimer = 0;
            }

            if (this.x < -50) this.markedForDeletion = true;
            if (this.hitFlash > 0) this.hitFlash--;
        }

        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            ctx.shadowBlur = 10; 
            ctx.shadowColor = this.color; 
            ctx.fillStyle = this.hitFlash > 0 ? '#FFFFFF' : this.color;
            
            if (this.type === 'TANK') {
                ctx.fillRect(-25, -25, 50, 50);
            } else if (this.type === 'KAMIKAZE') {
                ctx.beginPath(); ctx.moveTo(-20, 0); ctx.lineTo(20, -10); ctx.lineTo(20, 10); ctx.fill();
            } else {
                ctx.beginPath(); ctx.arc(0, 0, this.radius, 0, Math.PI * 2); ctx.fill();
                ctx.fillStyle = '#FFF'; ctx.beginPath(); ctx.arc(0, -5, 8, 0, Math.PI * 2); ctx.fill();
            }
            ctx.restore();
        }

        takeDamage() {
            this.hp--;
            this.hitFlash = 5;
            if (this.hp <= 0) {
                this.markedForDeletion = true;
                // Chance to drop powerup
                if (Math.random() < 0.15) { // 15% chance
                    const types = ['S', 'P', 'R'];
                    const t = types[Math.floor(Math.random() * types.length)];
                    powerups.push(new PowerUp(this.x, this.y, t));
                }
                return true; // killed
            }
            return false;
        }
    }

    class Boss {
        constructor() {
            this.width = 100; this.height = 100;
            this.x = GAME_WIDTH + 150; this.y = GAME_HEIGHT / 2;
            this.hp = 80 + (level * 20);
            this.maxHp = this.hp;
            this.state = 'enter'; // enter, fight, charge, beam
            this.stateTimer = 0;
            this.hitFlash = 0;
            this.angle = 0;
        }
        update() {
            if (this.hitFlash > 0) this.hitFlash--;
            
            // Movement logic
            if (this.state === 'enter') {
                this.x -= 2;
                if (this.x < GAME_WIDTH - 150) {
                    this.state = 'fight';
                    this.stateTimer = 0;
                }
            } else if (this.state === 'fight') {
                this.y += Math.sin(Date.now() / 500) * 2;
                this.stateTimer++;

                // Normal attack
                if (this.stateTimer % 60 === 0) {
                    for(let i=-1; i<=1; i++) {
                        enemyMissiles.push(new EnemyMissile(this.x - 50, this.y, -6, i*2, 8));
                    }
                }

                // Switch to Beam attack occasionally
                if (this.stateTimer > 300) {
                    this.state = 'charge';
                    this.stateTimer = 0;
                    sfx.bossCharge();
                }
            } else if (this.state === 'charge') {
                this.stateTimer++;
                // Shake before firing
                this.x += (Math.random() - 0.5) * 5;
                if (this.stateTimer > 60) {
                    this.state = 'beam';
                    this.stateTimer = 0;
                    sfx.bossLaser();
                    addShake(20);
                }
            } else if (this.state === 'beam') {
                this.stateTimer++;
                // Beam logic is handled in collision/draw
                if (this.stateTimer > 50) {
                    this.state = 'fight';
                    this.stateTimer = 0;
                }
            }
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            
            // Beam drawing
            if (this.state === 'charge') {
                ctx.fillStyle = `rgba(255, 0, 0, ${this.stateTimer/60})`;
                ctx.fillRect(-800, -10, 800, 20); // Warning line
            }
            if (this.state === 'beam') {
                ctx.shadowBlur = 40; ctx.shadowColor = '#FF0000';
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(-800, -40, 800, 80); // Giant Beam
            }

            // Boss Body
            ctx.shadowBlur = 30; ctx.shadowColor = COLORS.boss; 
            ctx.fillStyle = this.hitFlash > 0 ? '#FFF' : '#222';
            ctx.strokeStyle = COLORS.boss; ctx.lineWidth = 4;
            
            ctx.beginPath();
            ctx.moveTo(50, 0); ctx.lineTo(0, -60); ctx.lineTo(-50, 0); ctx.lineTo(0, 60);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            
            // Eye
            ctx.fillStyle = (this.state === 'charge' || this.state === 'beam') ? '#FF0000' : '#00FFFF';
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();

            // HP Bar
            ctx.fillStyle = '#555'; ctx.fillRect(-50, -80, 100, 10);
            ctx.fillStyle = 'lime'; ctx.fillRect(-50, -80, 100 * (this.hp / this.maxHp), 10);
            ctx.restore();
        }
    }

    class PowerUp {
        constructor(x, y, type) {
            this.x = x; this.y = y; this.type = type; // S, P, R
            this.vx = -2; this.vy = 0;
            this.markedForDeletion = false;
        }
        update() {
            this.x += this.vx; 
            this.y = this.y + Math.sin(this.x * 0.05) * 1; // Float
            if (this.x < 0) this.markedForDeletion = true;
        }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.shadowBlur = 10; ctx.shadowColor = COLORS.powerup;
            ctx.fillStyle = '#000'; ctx.strokeStyle = COLORS.powerup; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(0,0, 15, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            
            ctx.fillStyle = '#FFF'; ctx.font = 'bold 16px Arial'; ctx.textAlign = 'center'; ctx.textBaseline='middle';
            ctx.fillText(this.type, 0, 2);
            ctx.restore();
        }
    }

    class EnemyMissile {
        constructor(x, y, dx, dy, r) {
            this.x = x; this.y = y; this.dx = dx; this.dy = dy; this.r = r;
            this.markedForDeletion = false;
        }
        update() {
            this.x += this.dx; this.y += this.dy;
            if (this.x < -20 || this.y < -20 || this.y > GAME_HEIGHT+20) this.markedForDeletion = true;
        }
        draw() {
            ctx.save();
            ctx.shadowBlur = 5; ctx.shadowColor = COLORS.missile; ctx.fillStyle = COLORS.missile;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2); ctx.fill();
            ctx.restore();
        }
    }

    // --- Core Functions ---

    function initStars() {
        stars = [];
        for(let i=0; i<100; i++) {
            stars.push({
                x: Math.random() * GAME_WIDTH,
                y: Math.random() * (GAME_HEIGHT - 100),
                size: Math.random() * 2,
                speed: Math.random() * 0.5 + 0.1
            });
        }
    }

    function addShake(amount) { shakeIntensity = amount; }

    function createExplosion(x, y, color, size=1) {
        sfx.explosion();
        for(let i=0; i<10 * size; i++) {
            particles.push({
                x: x, y: y, color: color,
                vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                life: 1.0, decay: Math.random()*0.05 + 0.02
            });
        }
    }

    function addScore(points) {
        score += points * (1 + (combo > 5 ? 1 : 0)); // 2x multiplier if combo > 5
        combo++;
        comboTimer = 120; // 2 seconds to keep combo
        
        const hud = document.getElementById('comboDisplay');
        hud.innerHTML = `COMBO x${combo}`;
        hud.style.opacity = 1;

        // Level Up check
        if (score > level * 1500) {
            level++;
            sfx.playTone('sine', 600, 1200, 0.5);
            glitchTimer = 30;
            spawnRate += 0.005;
            document.getElementById('levelDisplay').innerText = `LEVEL ${level}`;
            if (level % 2 === 0) boss = new Boss();
        }
    }

    function updateCombo() {
        if (comboTimer > 0) {
            comboTimer--;
            if (comboTimer <= 0) {
                combo = 0;
                document.getElementById('comboDisplay').style.opacity = 0;
            }
        }
    }

    // --- Main Loop ---

    let pObj = new Player();
    let spawnRate = 0.015;

    function gameLoop() {
        if (gameState !== 'PLAYING') return;

        // 1. Update State
        scrollOffset += scrollSpeed;
        updateCombo();
        
        // Shake logic
        let dx = 0, dy = 0;
        if (shakeIntensity > 0) {
            dx = (Math.random() - 0.5) * shakeIntensity;
            dy = (Math.random() - 0.5) * shakeIntensity;
            shakeIntensity *= 0.9;
            if (shakeIntensity < 0.5) shakeIntensity = 0;
        }

        ctx.save();
        ctx.translate(dx, dy); // Apply Shake

        // 2. Clear & Draw Background
        ctx.fillStyle = COLORS.bg;
        ctx.fillRect(-10, -10, GAME_WIDTH+20, GAME_HEIGHT+20);
        
        // Stars
        stars.forEach(s => {
            s.x -= s.speed;
            if (s.x < 0) s.x = GAME_WIDTH;
            ctx.fillStyle = '#FFF'; ctx.fillRect(s.x, s.y, s.size, s.size);
        });

        drawGrid();
        drawTerrain();

        // 3. Spawning
        if (!boss || boss.state === 'enter') {
            if (Math.random() < spawnRate) {
                const rand = Math.random();
                let type = 'NORMAL';
                if (rand < 0.2 && level > 1) type = 'KAMIKAZE';
                if (rand < 0.1 && level > 2) type = 'TANK';
                enemies.push(new Enemy(type));
            }
            // Ground missiles
            if (Math.random() < 0.005) {
                groundMissiles.push({x: Math.random()*600+100, y: 600, w:8, h:20, spd:4, del:false});
            }
        }

        // 4. Update & Draw Entities
        pObj.update();
        pObj.draw();

        if (boss) { boss.update(); boss.draw(); }

        lasers.forEach(o => { o.update(); o.draw(); });
        enemies.forEach(o => { o.update(); o.draw(); });
        enemyMissiles.forEach(o => { o.update(); o.draw(); });
        powerups.forEach(o => { o.update(); o.draw(); });
        
        groundMissiles.forEach(gm => {
            gm.y -= gm.spd;
            if (gm.y < 0) gm.del = true;
            ctx.fillStyle = '#FFFF00'; ctx.fillRect(gm.x, gm.y, gm.w, gm.h);
        });

        // Particles
        particles.forEach(p => {
            p.x += p.vx; p.y += p.vy; p.life -= p.decay;
            ctx.globalAlpha = p.life; ctx.fillStyle = p.color;
            ctx.beginPath(); ctx.arc(p.x, p.y, Math.random()*3, 0, Math.PI*2); ctx.fill();
        });
        ctx.globalAlpha = 1;

        // Cleanup
        lasers = lasers.filter(o => !o.markedForDeletion);
        enemies = enemies.filter(o => !o.markedForDeletion);
        enemyMissiles = enemyMissiles.filter(o => !o.markedForDeletion);
        powerups = powerups.filter(o => !o.markedForDeletion);
        groundMissiles = groundMissiles.filter(o => !o.del);
        particles = particles.filter(p => p.life > 0);

        // 5. Collisions
        checkCollisions();

        // 6. Glitch Effect
        if (glitchTimer > 0) {
            glitchTimer--;
            const h = Math.random() * 50;
            const y = Math.random() * 600;
            ctx.fillStyle = `rgba(${Math.random()*255},255,255,0.3)`;
            ctx.fillRect(0, y, 800, h);
        }

        ctx.restore(); // Undo Shake
        
        document.getElementById('scoreVal').innerText = Math.floor(score);
        requestAnimationFrame(gameLoop);
    }

    function checkCollisions() {
        // Lasers vs Enemies/Boss
        lasers.forEach(l => {
            enemies.forEach(e => {
                if (!l.markedForDeletion && !e.markedForDeletion && dist(l.x,l.y, e.x,e.y) < e.radius + 10) {
                    l.markedForDeletion = true;
                    if (e.takeDamage()) {
                        addScore(100);
                        createExplosion(e.x, e.y, e.color);
                        addShake(5);
                    } else {
                        sfx.hit();
                    }
                }
            });
            if (boss && boss.state === 'fight' && !l.markedForDeletion) {
                if (l.x > boss.x - 50 && l.x < boss.x + 50 && Math.abs(l.y - boss.y) < 50) {
                    l.markedForDeletion = true;
                    boss.hp--;
                    boss.hitFlash = 5;
                    sfx.hit();
                    if (boss.hp <= 0) {
                        createExplosion(boss.x, boss.y, '#FFF', 5);
                        addShake(30);
                        score += 5000;
                        boss = null;
                    }
                }
            }
        });

        // Player Collisions
        if (pObj.invulnerable <= 0) {
            let hit = false;
            // Vs Enemy Body
            enemies.forEach(e => { if (dist(pObj.x,pObj.y, e.x,e.y) < 30) hit = true; });
            // Vs Missiles
            enemyMissiles.forEach(m => { if (dist(pObj.x,pObj.y, m.x,m.y) < 15) hit = true; });
            groundMissiles.forEach(gm => { if (dist(pObj.x,pObj.y, gm.x, gm.y) < 20) hit = true; });
            // Vs Boss Beam
            if (boss && boss.state === 'beam') {
                if (Math.abs(pObj.y - boss.y) < 40) hit = true;
            }

            if (hit) {
                if (pObj.hit()) gameOver();
            }
        }

        // Powerup Collection
        powerups.forEach(p => {
            if (dist(pObj.x, pObj.y, p.x, p.y) < 30) {
                p.markedForDeletion = true;
                sfx.powerup();
                addScore(50);
                if (p.type === 'S') { pObj.powerUpType = 'TRIPLE'; pObj.powerUpTimer = 600; }
                if (p.type === 'R') { pObj.powerUpType = 'RAPID'; pObj.powerUpTimer = 600; }
                if (p.type === 'P') { pObj.hasShield = true; }
            }
        });

        // Terrain
        if (pObj.y + 10 > getTerrainHeight(pObj.x)) {
             if(pObj.hit()) gameOver();
        }
    }

    // --- Helpers ---
    function dist(x1,y1,x2,y2) { return Math.hypot(x1-x2, y1-y2); }
    
    function drawGrid() {
        ctx.save(); ctx.strokeStyle = COLORS.grid; ctx.globalAlpha = 0.2;
        // Simplified perspective lines
        for(let x=0; x<GAME_WIDTH; x+=50) {
            ctx.beginPath(); ctx.moveTo(x, GAME_HEIGHT); ctx.lineTo((x-400)*0.2 + 400, 0); ctx.stroke();
        }
        // Horizontal lines moving
        const off = scrollOffset % 50;
        for(let y=0; y<GAME_HEIGHT; y+=50) {
            let py = y + off;
            if(py > GAME_HEIGHT) py -= GAME_HEIGHT;
            ctx.beginPath(); ctx.moveTo(0, py); ctx.lineTo(GAME_WIDTH, py); ctx.stroke();
        }
        // Standard vertical scrolling grid
        const gw = 60;
        const gx = scrollOffset % gw;
        for(let x = -gx; x<GAME_WIDTH; x+=gw) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, GAME_HEIGHT); ctx.stroke();
        }
        for(let y=0; y<GAME_HEIGHT; y+=gw) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(GAME_WIDTH, y); ctx.stroke();
        }
        ctx.restore();
    }

    function getTerrainHeight(x) {
        const wx = x + scrollOffset;
        return GAME_HEIGHT - 60 - (Math.sin(wx*0.005)*60 + Math.sin(wx*0.012)*30);
    }
    
    function drawTerrain() {
        ctx.save(); ctx.fillStyle = '#1a0026'; ctx.strokeStyle = '#9400D3';
        ctx.shadowBlur=15; ctx.shadowColor='#9400D3'; ctx.lineWidth=3;
        ctx.beginPath(); ctx.moveTo(0, GAME_HEIGHT);
        for(let x=0; x<=GAME_WIDTH; x+=10) ctx.lineTo(x, getTerrainHeight(x));
        ctx.lineTo(GAME_WIDTH, GAME_HEIGHT); ctx.fill(); ctx.stroke(); ctx.restore();
    }

    // --- Control ---
    function startGame() {
        if (gameState === 'PLAYING') return;
        
        canvas.focus(); // Focus canvas to ensure key inputs are directed here
        try { initAudio(); } catch(e) { console.warn(e); }
        
        startBGM();
        document.getElementById('startScreen').classList.add('hidden');
        resetGame();
        gameState = 'PLAYING';
        gameLoop();
    }
    function restartGame() {
        if (gameState === 'PLAYING') return;
        document.getElementById('gameOverScreen').classList.add('hidden');
        resetGame();
        gameState = 'PLAYING';
        gameLoop();
    }
    function gameOver() {
        gameState = 'GAMEOVER';
        createExplosion(pObj.x, pObj.y, COLORS.player, 5);
        addShake(20);
        stopBGM();
        if (score > highScore) {
            highScore = score;
            localStorage.setItem('synthShooterHighScore', highScore);
            document.getElementById('highScoreVal').innerText = Math.floor(highScore);
        }
        document.getElementById('finalScore').innerText = Math.floor(score);
        document.getElementById('gameOverScreen').classList.remove('hidden');
    }
    function resetGame() {
        score = 0; level = 1; combo = 0; scrollSpeed = 3;
        enemies=[]; lasers=[]; enemyMissiles=[]; groundMissiles=[]; powerups=[]; particles=[];
        boss = null;
        pObj = new Player();
        initStars();
        document.getElementById('levelDisplay').innerText = "LEVEL 1";
    }

    window.addEventListener('blur', () => { Object.keys(keys).forEach(k => keys[k] = false); });

    document.addEventListener('keydown', e => {
        // Robust key tracking
        if(e.code && keys.hasOwnProperty(e.code)) keys[e.code] = true;
        if(e.key === ' ') keys['Space'] = true;
        
        // Prevent default scrolling/action for game keys
        if(['Space', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.code) || e.key === ' ') {
            e.preventDefault();
            e.stopPropagation(); // Stop event from bubbling
        }

        if(e.code === 'Space' || e.key === ' ') {
            if(gameState === 'START') startGame();
            else if(gameState === 'GAMEOVER') restartGame();
        }
    }, { capture: true });
    window.addEventListener('keyup', e => { if(keys.hasOwnProperty(e.code)) keys[e.code] = false; });
    
    // Init
    initStars();
    ctx.fillStyle='#000'; ctx.fillRect(0,0,800,600); drawGrid(); drawTerrain();
    document.getElementById('highScoreVal').innerText = highScore;

</script>
</body>
</html>